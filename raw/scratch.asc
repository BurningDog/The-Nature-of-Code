The Nature of Code
==================

Chapter whatever
----------------

include::chapters/mathsvgfiles.asc[]
//include::chapters/math.asc[]


[[chapter06_section8]]
=== 6.8  Path Following

((("autonomous agents","path following")))
((("path following")))
((("path following","pathfinding vs.")))
((("pathfinding")))
((("Reynolds, Craig","path following algorithm")))

Now that we’ve got a basic understanding of the dot product under our belt, we can return to a discussion of Craig Reynolds’s path-following algorithm.     Let’s quickly clarify something.  We are talking about path _following_, not path _finding_.  Pathfinding refers to a research topic (commonly studied in artificial intelligence) that involves solving for the shortest distance between two points, often in a maze.   With *_path following_*, the path already exists and we’re asking a vehicle to follow that path.

Before we work out the individual pieces, let’s take a look at the overall algorithm for path following, as defined by Reynolds.

[[chapter06_figure20]]
image::imgs/chapter06/ch06_20.png[alt="Figure 6.20"]


((("path")))

We'll first define what we mean by a path.  There are many ways we could implement a path, but for us, a simple way will be to define a path as a series of connected points:

[[chapter06_figure21]]
image::imgs/chapter06/ch06_21.png[alt="Figure 6.21: Path"]

An even simpler path would be a line between two points.

[[chapter06_figure22]]
image::imgs/chapter06/ch06_22.png[alt="Figure 6.22: Simple path"]

We’re also going to consider a path to have a radius.  If we think of the path as a road, the radius determines the road’s width.  With a smaller radius, our vehicles will have to follow the path more closely; a wider radius will allow them to stray a bit more.

Putting this into a class, we have:

image::imgs/chapter06/ch06_ex5_a.png[classname="screenshot"]

[source,java]
----
class Path {

  //[full] A Path is only two points, start and end.
  PVector start;
  PVector end;
  //[end]
  
  // A path has a radius, i.e. how wide it is.
  float radius;

  Path() {
    // Picking some arbitrary values to initialize the path
    radius = 20;
    start = new PVector(0,height/3);
    end = new PVector(width,2*height/3);
  }

  void display() {  // Display the path.
    strokeWeight(radius*2);
    stroke(0,100);
    line(start.x,start.y,end.x,end.y);
    strokeWeight(1);
    stroke(0);
    line(start.x,start.y,end.x,end.y);
  }
}
----

Now, let’s assume we have a vehicle (as depicted below) outside of the path’s radius, moving with a velocity.

[[chapter06_figure23]]
image::imgs/chapter06/ch06_23.png[alt="Figure 6.23"]

The first thing we want to do is predict, assuming a constant velocity, where that vehicle will be in the future.

[source,java]
----
// Start by making a copy of the velocity.
PVector predict = vel.get();  

//[full] Normalize it and look 25 pixels 
// ahead by scaling the vector up.
predict.normalize();    
predict.mult(25);
//[end]

// Add vector to location to find the 
// predicted location.
PVector predictLoc = PVector.add(loc, predict);
----

((("path following","current distance from path, finding")))

Once we have that location, it’s now our job to find out the vehicle's current distance from the path of that predicted location.  If it’s very far away, well, then, we’ve strayed from the path and need to steer back towards it.  If it’s close, then we’re doing OK and are following the path nicely.

So, how do we find the distance between a point and a line?  This concept is key.  The distance between a point and a line is defined as the length of the normal between that point and line.  The normal is a vector that extends from that point and is perpendicular to the line.

[[chapter06_figure24]]
image::imgs/chapter06/ch06_24.png[alt="Figure 6.24"]

Let’s figure out what we do know.    We know we have a vector (call it {vectorA}) that extends from the path’s starting point to the vehicle’s predicted location.

[source,java]
----
PVector a = PVector.sub(predictLoc,path.start);
----

We also know that we can define a vector (call it {vectorb}) that points from the start of the path to the end. 

[source,java]
----
PVector b = PVector.sub(path.end,path.start);
----

Now, with basic trigonometry, we know that the distance from the path’s start to the normal point is: [formula]*|A| * cos(theta)*.  

[[chapter06_figure25]]
image::imgs/chapter06/ch06_25.png[alt="Figure 6.25"]

If we knew theta, we could easily define that normal point as follows:

[source,java]
----
// The distance from START to NORMAL
float d = a.mag()*cos(theta); 
b.normalize();
// Scale PVector b to that distance.
b.mult(d);
// The normal point can be found by adding
// the scaled version of b to the path’s 
// starting point.
PVector normalPoint = PVector.add(path.start,b);
----

And if the dot product has taught us anything, it’s that given two vectors, we can get theta, the angle between.

[source,java]
----
// What is theta?  The angle between A and B
float theta = PVector.angleBetween(a,b);
b.normalize();
b.mult(a.mag()*cos(theta));
PVector normalPoint = PVector.add(path.start,b);
----

While the above code will work, there’s one more simplification we can make.   If you’ll notice, the desired magnitude for vector {vectorb} is:

[formula]*a.mag()*cos(theta)*

which is the code translation of:

{maga} {mult} {costheta}

And if you recall: 

{vectora} {dot} {vectorb} {equals} {maga} {mult} {magb} {mult} {costheta}

Now, what if vector {vectorb} is a unit vector, i.e. length 1?  Then:

{vectora} {dot} {vectorb} {equals} {maga} {mult} {one} {mult} {costheta}

or

{vectora} {dot} {vectorb} {equals} {maga} {mult} {costheta}

And what are we doing in our code?  Normalizing b!

[source,java]
----
b.normalize();
----

Because of this fact, we can simplify our code as:

[source,java]
----
float theta = PVector.angleBetween(a,b); //[line-through]

b.normalize();
// We can use the dot product to scale b’s length.
b.mult(a.dot(b)); 

PVector normalPoint = PVector.add(path.start,b);
----

[[chapter06_figure26]]
image::imgs/chapter06/ch06_26.png[alt="Figure 6.26",classname="half-width"]

((("scalar projection")))
((("scalar projection")))

This process is commonly known as “scalar projection.”  *_|A| cos(θ) is the scalar projection of A onto B._*  And if we normalize B before computing the dot product, the scalar projection of A onto B is equal to A • B.

((("normal points")))
((("path following","normal points")))

Once we have the normal point along the path, we have to decide whether the vehicle should steer towards the path and how.  Reynolds’s algorithm states that the vehicle should only steer towards the path if it strays beyond the path (i.e., if the distance between the normal point and the predicted future location is greater than the path radius).

[[chapter06_figure27]]
image::imgs/chapter06/ch06_27.png[alt="Figure 6.27"]

[source,java]
----
float distance = PVector.dist(predictLoc, normalPoint);

// If the vehicle is outside the path,
// seek the target.
if (distance > path.radius) {   
  // We don’t have to work out the desired velocity and
  // steering force; all that is taken care of by seek(),
  // which we already wrote in Example 6.1.
  seek(target);     
}            
----

But what is the target?

((("path following","target, determining")))

Reynolds’s algorithm involves picking a point ahead of the normal on the path (see step #3 above).  But for simplicity, we could just say that the target is the normal itself. This will work fairly well:

[source,java]
----
float distance = PVector.dist(predictLoc, normalPoint);
if (distance > path.radius) {
  // Seek the normal point on the path.
  seek(normalPoint);    
}
----

Since we know the vector that defines the path (we’re calling it “B”), we can implement Reynolds’s “point ahead on the path” without too much trouble.

[[chapter06_figure28]]
image::imgs/chapter06/ch06_28.png[alt="Figure 6.28"]

[source,java]
----
float distance = PVector.dist(predictLoc, normalPoint);
if (distance > path.radius) {
  //[full] Normalize and scale b (pick 25 pixels arbitrarily).
  b.normalize();   
  b.mult(25);
  //[end]
  // By adding b to normalPoint, we now move 
  // 25 pixels ahead on the path.
  PVector target = PVector.add(normalPoint,b);  

  seek(target);
}
----

Putting it all together, we have the following steering function in our [klass]*Vehicle* class.

image::imgs/chapter06/ch06_ex5.png[canvas="processingjs/chapter06/_6_05_PathFollowingSimple/_6_05_PathFollowingSimple.pde processingjs/chapter06/_6_05_PathFollowingSimple/Path.pde processingjs/chapter06/_6_05_PathFollowingSimple/Vehicle.pde",classname="screenshot"]

[[chapter06_example5]]
[example]*Example 6.5: Simple path following*

[source,java]
----
  void follow(Path p) {

    //[full] Step 1: Predict the vehicle’s future location.
    PVector predict = vel.get();
    predict.normalize();
    predict.mult(25);
    PVector predictLoc = PVector.add(loc, predict);
    //[end]

    //[full] Step 2: Find the normal point along the path.
    PVector a = p.start;
    PVector b = p.end;
    PVector normalPoint = getNormalPoint(predictLoc, a, b);
    //[end]
   
    //[full] Step 3: Move a little further along the path and set a target.
    PVector dir = PVector.sub(b, a);
    dir.normalize();
    dir.mult(10);
    PVector target = PVector.add(normalPoint, dir);
    //[end]

    //[full] Step 4: If we are off the path,
    // seek that target in order to stay on the path.
    float distance = PVector.dist(normalPoint, predictLoc);
    if (distance > p.radius) {
      seek(target);
    }//[end]
  }
----

Now, you may notice above that instead of using all that dot product/scalar projection code to find the normal point, we instead call a function: [function]*getNormalPoint()*.   In cases like this, it’s useful to break out the code that performs a specific task (finding a normal point) into a function that it can be used generically in any case where it is required.  The function takes three [klass]*PVector*++s++: the first defines a point in Cartesian space and the second and third arguments define a line segment.

[[chapter06_figure29]]
image::imgs/chapter06/ch06_29.png[alt="Figure 6.29"]

[source,java]
----
  PVector getNormalPoint(PVector p, PVector a, PVector b) {
    // PVector that points from a to p
    PVector ap = PVector.sub(p, a); 
    // PVector that points from a to b
    PVector ab = PVector.sub(b, a); 
    
    //[full] Using the dot product for scalar projection
    ab.normalize();     
    ab.mult(ap.dot(ab));
    //[end]
    // Finding the normal point along the line segment  
    PVector normalPoint = PVector.add(a, ab);
    
    return normalPoint;
  }
----

What do we have so far?  We have a [klass]*Path* class that defines a path as a line between two points.  We have a [klass]*Vehicle* class that defines a vehicle that can follow the path (using a steering behavior to seek a target along the path).  What is missing?

Take a deep breath.  We’re almost there. 

