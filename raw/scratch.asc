The Nature of Code
==================

Introduction
------------

[quote, — Woody Allen]
__________________________________________
“I am two with nature.”
__________________________________________

Here we are: the beginning.  Well, almost the beginning. If it’s been a while since you’ve done any programming in Processing (or any math, for that matter), this introduction will get your mind back into computational thinking before we approach some of the more difficult and complex material.

In Chapter 1, we’re going to talk about the concept of a vector and how it will serve as the building block for simulating motion throughout this book.   But before we take that step, let’s think about what it means for something to simply move around the screen.   Let’s begin with one of the best-known and simplest simulations of motion—the random walk.

[[intro_section1]]
=== I.1 Random Walks

((("random walks")))

Imagine you are standing in the middle of a balance beam.  Every ten seconds, you flip a coin.  Heads, take a step forward.  Tails, take a step backward.   This is a random walk—a path defined as a series of random steps.    Stepping off that balance beam and onto the floor, you could perform a random walk in two dimensions by flipping that same coin twice with the following results:

[options="header"]
|=======================
|Flip 1 |Flip 2 |Result
|Heads  |Heads  |Step forward.
|Heads  |Tails  |Step right.
|Tails  |Heads  |Step left.
|Tails  |Tails  |Step backward.
|=======================

Yes, this may seem like a particularly unsophisticated algorithm.  Nevertheless, random walks can be used to model phenomena that occur in the real world, from the movements of molecules in a gas to the behavior of a gambler spending a day at the casino.  As for us, we begin this book studying a random walk with three goals in mind.

((("natural phenomena","modeling with random walks")))

. We need to review a programming concept central to this book—object-oriented programming.  The random walker will serve as a template for how we will use object-oriented design to make things that move around a Processing window.
. The random walk instigates the two questions that we will ask over and over again throughout this book: “How do we define the rules that govern the behavior of our objects?” and then, “How do we implement these rules in Processing?”
. Throughout the book, we’ll periodically need a basic understanding of randomness, probability, and Perlin noise.  The random walk will allow us to demonstrate a few key points that will come in handy later.

[[intro_section2]]
=== I.2 The Random Walker Class

((("object-oriented programming","review of")))
((("Processing","review of object-oriented programming with")))

Let’s review a bit of object-oriented programming (OOP) first by building a [klass]*Walker* object.   This will be only a cursory review.  If you have never worked with OOP before, you may want something more comprehensive; I’d suggest stopping here and reviewing the http://processing.org/learning/objects/[basics on the Processing website] before continuing.   

((("object","defined")))
((("object-oriented programming","object")))

An *_object_* in Processing is an entity that has both data and functionality.  We are looking to design a [klass]*Walker* object that both keeps track of its data (where it exists on the screen) and has the capability to perform certain actions (such as draw itself or take a step).

((("class (Processing)","defined")))
((("object-oriented programming","class")))

A *_class_* is the template for building actual instances of objects.  Think of a class as the cookie cutter; the objects are the cookies themselves.      

Let’s begin by defining the [klass]*Walker* class—what it means to be a [klass]*Walker* object.  The [klass]*Walker* only needs two pieces of data—a number for its x-location and one for its y-location.

[source,java]
----
class Walker {
  //[full] Objects have data.   
  int x;
  int y;
  //[end]
----


((("class (Processing)","constructor")))
((("constructor")))

Every class must have a constructor, a special function that is called when the object is first created.  You can think of it as the object’s [function]*setup()*.   There, we’ll initialize the [klass]*Walker*++’++s starting location (in this case, the center of the window).

[source,java]
----
  //[full] Objects have a constructor where they are initialized.
  Walker() {    
    x = width/2;
    y = height/2;
  }
  //[end]
----

((("class (Processing)","functionality")))
((("functionality")))

Finally, in addition to data, classes can be defined with functionality.  In this example, a [klass]*Walker* has two functions.   We first write a function that allows the object to display itself (as a white dot).

[source,java]
----
  //[full] Objects have functions.
  void display() {    
    stroke(255);
    point(x,y);
  }
  //[end]
----


The second function directs the [klass]*Walker* object to take a step.   Now, this is where things get a bit more interesting.   Remember that floor on which we were taking random steps?  Well, now we can use a Processing window in that same capacity.  There are four possible steps. A step to the right can be simulated by incrementing [var]*x* ([var]*x*`++`); to the left by decrementing [var]*x* ([var]*x--*); forward by going down a pixel ([var]*y++*); and backward by going up a pixel ([var]*y--*).   How do we pick from these four choices?   Earlier we stated that we could flip two coins.  In Processing, however, when we want to randomly choose from a list of options, we can pick a random number using [function]*random()*.

((("random number generators","random() function")))
((("random() function")))

[source,java]
----
  void step() {
    // 0, 1, 2, or 3
    int choice = int(random(4));
----

The above line of code picks a random floating point number between 0 and 4 and converts it to an integer, with a result of 0, 1, 2, or 3.   Technically speaking, the highest number will never be 4.0, but rather 3.999999999 (with as many 9s as there are decimal places); since the process of converting to an integer lops off the decimal place, the highest [var]*int* we can get is 3.  Next, we take the appropriate step (left, right, up, or down) depending on which random number was picked.

[source,java]
----
    //[full] The random “choice” determines our step.
    if (choice == 0) {      
      x++;
    } else if (choice == 1) {
      x--;
    } else if (choice == 2) {
      y++;
    } else {
      y--;
    }
    //[end]
  }
}
----

////
include::chapters/00_1_titlepage.asc[]

++++
<div id="frontmatter"> 
++++

//include::chapters/00_0_welcome.asc[]

include::chapters/00_2_dedication.asc[]

include::chapters/00_3_creditscopyright.asc[]

include::chapters/00_6_TOC.asc[]

++++
</div>
<div id="contents"> 
++++

include::chapters/mathsvgfiles.asc[]

include::chapters/00_7_intro.asc[]

include::chapters/01_vectors.asc[]

include::chapters/xx_1_furtherreading.asc[]

include::chapters/xx_2_index.asc[]

++++
</div>
++++
////


